## Abstraction of control 
- Subprograms, blocks, parameters
  ![[Pasted image 20230306155523.png]]
Without not knowing the code it is possible to
- Specify P
- Write P
- Use P

Abstraction of control
- Provide functional abstraction of the project
  - Each component provides services to its environment
  - Its abstraction describes the external behaviour
  - Hide the interior details needed to produce
- Interactions limited to external behaviour
- Communication through
  - Parameters
  - Global environment / variables (destroys abstraction)

Parameters
- Terminology
  - Declaration / definition
    int f (int n) (return n + 1; )
- Use / call
  x = f (y + 3)
- Concrete: information flow between caller and callee
  main -> proc
  - x = f(y+3)
  main <- proc
  - Procedure one (var y:integer); begin y:=1 end;
  main <--> proc
  - Procedure succ /var y:integer); begin y:=y+1 end;

Parameter passing
- Two main ways
  - By value or by reference
- By value
  - The value of the actual parameter is assigned to the formal, which behaves like a local variable
  - Main -> proc
  - Actual parameter any; changes to the formal do not pass to the actual
- By reference
- is passed a reference (address) at the actual parameter, references to the formal are references to the actual (aliasing)
- Main <--> Proc
- Actual: variable; changes to the formal pass to actual

Call by value
![[Pasted image 20230306160519.png]]
- The formal x is local var (on stack)
- At the call the actual y+1 is assessed and the value is assigned to the formal x
- No connection between x in the body of foo and y in the caller 
- on return from foo x is destroyed removed from stack
- you cannot pass info from foo to the caller using the parameter 
- expensive for large data - copying 
- Java, Scheme, Pascal (default), C

Call by reference (of variable)
![[Pasted image 20230306160708.png]]
- A reference is passed (address, point)
- The formal x is an alias of y
- The actual must be an l-value ("a variable")
- On return from foo it is destroyed only the bond between x and the address of y
- Two-way transmission between caller and callee
- Efficient in the passage
- Pascal (var); in C done by passing a pointer
- Java does it both ways depending on what is passed ints is by value and objects is by reference
- The actual parameter / variable passed must be an actual reference cannot be like  1 + 2 this is not possible

Call by constant
- Want to parse information by reference but not having the subprogram modify it during the subprograms execution
- In java final in front of parameters
- done for performance reasons if you are sure you are not going to modify the parameter
- Compiler needs to check that you are not modifying the variable
- small parameter is passed by value 
- large parameter is passed by reference

Call by result 
![[Pasted image 20230313144052.png]]
- information goes from subprogram to main-program
- The parameter initialized in the subprogram at the end of execution is copied back to the passed variable from the main program
- No connection between x and y in the program
- x is removed from stack when foo is done
- not possible to pass info from the caller to foo using the parameter
- expensive for large data : copy 

call by value/result
![[Pasted image 20230313144257.png]]
- x is in all respects a local var (on the stack)
- To the call, the value of the actual is assigned to the formal
- On return, the value of the formal is assigned to the actual
- No connection between x in the body of foo and y in the caller
- On return from foo, x is destroyed (removed from the stack)
- expensive for large data : copy 

Value-result != reference
![[Pasted image 20230313144639.png]]

# Value and reference: summary
- Value
  - Simple semantics: the body does not need to know how the
  - procedure will be called (referential transparency)
  - Fairly simple implementation
  - Potentially expensive pass, efficient reference to the formal (direct access) 
  - Need for other mechanisms to communicate main ← proc
- Reference
  - Complex semantics; aliasing
  - simple implementation
  - efficient passing; a little more expensive the reference to the formal parameter (indirect access)

# Value and not reference
- Benefits of passing by value
  - simple to see what happens → no changes in caller
- Suggests languages with call by value only + separate mechanisms to get the call by reference: pointers in C classes types in Java

Back to basics call by name
![[Pasted image 20230313145544.png]]
- similar to call by reference but the entire argument is copied as a name to the function 
- see a call as a macro expansion
  - The use of macro name with set of actual parameters is replaced by some code generated by its body
  - the semantics of a call consist in the execution of the body as if it were textually replaced there
- simple mechanism to uniquely define the semantics of a procedure
- Parameters: semantics consist in the execution of the body after the current parameters are syntactically substituted to the formal
- These are prescriptive rules of semantics
- Valuable capturing making sure that variables in a subprogram when replaced is not an actual variable it has to be a fresh variable
- if a side-effect like i++ is passed as a name the whole thing is copied so i++ will be copied and every time that variable is used it will generate side-effects 

Call by need
- Haskell is using lazy-evaluation aka Call by Need ○ Call by need is a variant of call by name (if the function argument is evaluated, that value is stored for subsequent use)

Call by name implementation
- cannot capture the variable (is when the name passed is the same as one defined inside the function)
- has to interpret the actual parameter in the context which is given 
- So the expressions has to be given as well as the evaluation environment (as in static scoping)
- So every time an expressions is evaluated it is evaluated in the given environment
- pass a pointer to the expression Exp -> pointer that tells you where to go to read the variable you need
- A (static chain) pointer on the stack to the activation record of the caller

Higher order functions
- Languages that allow you to pass functions to a method / procedure
- Return functions as a result of procedures
- Simple case
  - functions as an argument - need a pointer to the AR inside the stack: pass a closure
- More complicated 
  - function returned by procedure call - must keep the AR of the function returned -> stack data structure does not work anymore
- When a function is done executing within a subprogram its computations lost

Functions as a producer parameter 
![[Pasted image 20230313155017.png]]

Returning a function
![[Pasted image 20230313154357.png]]

Moral: functions as a result
- Use of closures, but when returning the AR is destroyed and so is the result. 
- AR persists indefinitely (solution)
  - Loss of stack properties
- Implementation
  - Do not explicitly deallocate
  - AR on the heap 
  - invokes the garbage collector when necessary

Deep / shallow binding
- Deep binding binds the environment at the time a procedure is passed as an argument -  Binding when calling the function that passes a function as a parameter (static scoping)
- Shallow binding binds the environment at the time a function passed as a parameter is actually called.

Closure
- a closure  is a tuple of (expression and the environment)
- Used to pass functions as arguments to other procedures
- Dynamically pass both the link with the code of the function and its non-local environment
- When a procedure call is made passed by parameter
  - allocate (as always) the AR
  - get static chain pointer from closure

Static scoping with functions as parameter 
![[Pasted image 20230313153043.png]]

Dynamic scope implementation
- Shallow binding
  - Does not require any attention
    - To access x, use the stack
    - Use of usual data structures (A-list, CRT)
- Deep binding
  - Necessary to use some form of closure to "freeze" a scope to reactive later

Dynamic scope
- Always use deep binding
- implemented with closures
- At first glance deep or shallow makes no difference
  - it is the static scope rule to determine which non-local to use
  - not always true (more than one block declaring the non-local name can be available; e.g., when recursion is present)

Deep and shallow binding with static scope
![[Pasted image 20230313154110.png]]
- Not super critical but something to keep in mind

Deep binding with static scope
![[Pasted image 20230313154252.png]]